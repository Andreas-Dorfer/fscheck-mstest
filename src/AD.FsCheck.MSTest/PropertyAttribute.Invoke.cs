// <auto-generated> This file was generated from 'PropertyAttribute.Invoke.tt'. </auto-generated>
#nullable enable
using FsCheck.Fluent;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace AD.FsCheck.MSTest;

public partial class PropertyAttribute
{
    static readonly MethodInfo Invoke1MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke1), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke1<T1>(Func<object[], bool> method) =>
        Prop.ForAll<T1>(values => method(new object[] { values! }));

    static readonly MethodInfo Invoke2MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke2), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke2<T1, T2>(Func<object[], bool> method) =>
        Prop.ForAll<Tuple<T1, T2>>(values => method(new object[] { values.Item1!, values.Item2! }));

    static readonly MethodInfo Invoke3MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke3), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke3<T1, T2, T3>(Func<object[], bool> method) =>
        Prop.ForAll<Tuple<T1, T2, T3>>(values => method(new object[] { values.Item1!, values.Item2!, values.Item3! }));

    static readonly MethodInfo Invoke4MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke4), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke4<T1, T2, T3, T4>(Func<object[], bool> method) =>
        Prop.ForAll<Tuple<T1, T2, T3, T4>>(values => method(new object[] { values.Item1!, values.Item2!, values.Item3!, values.Item4! }));

    static readonly MethodInfo Invoke5MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke5), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke5<T1, T2, T3, T4, T5>(Func<object[], bool> method) =>
        Prop.ForAll<Tuple<T1, T2, T3, T4, T5>>(values => method(new object[] { values.Item1!, values.Item2!, values.Item3!, values.Item4!, values.Item5! }));

    static readonly MethodInfo Invoke6MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke6), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke6<T1, T2, T3, T4, T5, T6>(Func<object[], bool> method) =>
        Prop.ForAll<Tuple<T1, T2, T3, T4, T5, T6>>(values => method(new object[] { values.Item1!, values.Item2!, values.Item3!, values.Item4!, values.Item5!, values.Item6! }));

    static readonly MethodInfo Invoke7MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke7), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke7<T1, T2, T3, T4, T5, T6, T7>(Func<object[], bool> method) =>
        Prop.ForAll<Tuple<T1, T2, T3, T4, T5, T6, T7>>(values => method(new object[] { values.Item1!, values.Item2!, values.Item3!, values.Item4!, values.Item5!, values.Item6!, values.Item7! }));

    bool TryGetInvokeMethodInfo(int count, [NotNullWhen(true)] out MethodInfo? methodInfo, [NotNullWhen(false)] out string? errorMsg)
    {
        methodInfo = null;
        errorMsg = null;

        switch (count)
        {
            case 0:
                errorMsg = "Properties must have at least one parameter.";
                return false;
            case 1:
                methodInfo = Invoke1MethodInfo;
                return true;
            case 2:
                methodInfo = Invoke2MethodInfo;
                return true;
            case 3:
                methodInfo = Invoke3MethodInfo;
                return true;
            case 4:
                methodInfo = Invoke4MethodInfo;
                return true;
            case 5:
                methodInfo = Invoke5MethodInfo;
                return true;
            case 6:
                methodInfo = Invoke6MethodInfo;
                return true;
            case 7:
                methodInfo = Invoke7MethodInfo;
                return true;
            default:
                errorMsg = $"The number of property parameters is limited to 7. The actual number is {count}.";
                return false;
                
        }
    }
}
