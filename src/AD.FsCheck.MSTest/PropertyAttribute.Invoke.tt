<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#const int count = 7; #>
// <auto-generated> This file was generated from 'PropertyAttribute.Invoke.tt'. </auto-generated>
using System.Reflection;

namespace AD.FsCheck.MSTest;

public partial class PropertyAttribute
{
<#
string types = "T1";
string typesTuple = "T1";
string values = "values!";
for(int i = 1; i <= count; i++)
{
#>
    static readonly MethodInfo Invoke<#= i #>MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke<#= i #>), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke<#= i #><<#= types #>>(Action<object[]> method) =>
        Prop.ForAll<<#= typesTuple #>>(values => method(new object[] { <#= values #> }));

<#
    if(i == 1)
    {
        values = "values.Item1!";
    }

    types += ", T" + (i + 1).ToString();
    typesTuple = "Tuple<" + types + ">";
    values += ", values.Item" + (i + 1).ToString() + "!";
}
#>
    MethodInfo GetInvokeMethodInfo(int count)=>
        count switch
        {
            0 => throw new InvalidOperationException($"Properties must have at least one parameter."),
<#
for(int i = 1; i <= count; i++)
{
#>
            <#= i #> => Invoke<#= i #>MethodInfo,
<#
}
#>
            _ => throw new InvalidOperationException($"The number of property parameters is limited to <#= count #>. The actual number is {count}.")
        };
}
