<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#const int count = 7; #>
// <auto-generated> This file was generated from 'PropertyAttribute.Invoke.tt'. </auto-generated>
#nullable enable
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace AD.FsCheck.MSTest;

public partial class PropertyAttribute
{
<#
string types = "T1";
string typesTuple = "T1";
string values = "values!";
for(int i = 1; i <= count; i++)
{
#>
    static readonly MethodInfo Invoke<#= i #>MethodInfo = typeof(PropertyAttribute).GetMethod(nameof(Invoke<#= i #>), BindingFlags.Static | BindingFlags.NonPublic)!;

    static Property Invoke<#= i #><<#= types #>>(Action<object[]> method) =>
        Prop.ForAll<<#= typesTuple #>>(values => method(new object[] { <#= values #> }));

<#
    if(i == 1)
    {
        values = "values.Item1!";
    }

    types += ", T" + (i + 1).ToString();
    typesTuple = "Tuple<" + types + ">";
    values += ", values.Item" + (i + 1).ToString() + "!";
}
#>
    bool TryGetInvokeMethodInfo(int count, [NotNullWhen(true)] out MethodInfo? methodInfo, [NotNullWhen(false)] out string? errorMsg)
    {
        methodInfo = null;
        errorMsg = null;

        switch (count)
        {
            case 0:
                errorMsg = "Properties must have at least one parameter.";
                return false;
<#
for(int i = 1; i <= count; i++)
{
#>
            case <#= i #>:
                methodInfo = Invoke<#= i #>MethodInfo;
                return true;
<#
}
#>
            default:
                errorMsg = $"The number of property parameters is limited to <#= count #>. The actual number is {count}.";
                return false;
                
        }
    }
}
